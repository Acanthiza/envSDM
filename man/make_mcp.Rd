% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_mcp.R
\name{make_mcp}
\alias{make_mcp}
\title{Minimum convex polygon around records}
\usage{
make_mcp(
  presence,
  out_file,
  force_new = FALSE,
  pres_x = "long",
  pres_y = "lat",
  in_crs = 4326,
  out_crs = in_crs,
  buf = 0,
  clip = NULL
)
}
\arguments{
\item{presence}{Cleaned and filtered dataframe of presences}

\item{out_file}{Character. Path for the mcp to be saved. Will be saved by
\code{sfarrow::st_write_parquet()}. Currently will not work very well with any
full stop in the path. Other file types are changed to .parquet}

\item{force_new}{Logical. If \code{out_file} exists, recreate it?}

\item{pres_x, pres_y}{Character. Name of the columns in \code{presence} that have
the x and y coordinates}

\item{in_crs}{epsg code for coordinates in \code{presence}}

\item{out_crs}{epsg code for coordinates in output mcp. Usually the same as
predictors}

\item{buf}{Distance to buffer the mcp. Passed to the \code{dist} argument of
\code{sf:st_buffer()} so units should follow that guidance.}

\item{clip}{sf to clip the mcp}
}
\value{
sf. \code{out_file} saved.
}
\description{
For use as predict boundary for a taxa, but also see
\code{make_predict_boundary()}
}
\examples{

out_dir <- file.path(system.file(package = "envSDM"), "examples")

data <- file.path(system.file(package = "predicts"), "ex") |>
  fs::dir_ls(regexp = "\\\\.csv$") |>
  tibble::enframe(name = NULL, value = "path") |>
  dplyr::mutate(taxa = gsub("\\\\.csv", "", basename(path))
                , presence = purrr::map(path, rio::import, setclass = "tibble", trust = TRUE)
                , presence = purrr::map(presence
                                        , \(x) x |>
                                          dplyr::filter(!is.na(lat)
                                                        , !is.na(lon)
                                          )
                )
                , out_dir = fs::path(out_dir, taxa)
                , out_mcp = fs::path(out_dir, "mcp.parquet")
  )


# mcps --------

purrr::pwalk(list(data$presence
                  , data$out_mcp
)
, \(x, y) make_mcp(x, y, pres_x = "lon")
)
}
