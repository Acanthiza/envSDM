% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_sdm.R
\name{tune_sdm}
\alias{tune_sdm}
\title{Tune, and evaluate, species distribution models}
\usage{
tune_sdm(
  this_taxa = NULL,
  out_dir,
  algo = c("all", "maxnet", "bioclim", "envelope", "rf"),
  fc = "auto_feature",
  limit_p = FALSE,
  rm = seq(1, 6, 0.5),
  trees = c(500, 1000, 2000),
  mtry = TRUE,
  nodesize = c(1, 2),
  keep_model = FALSE,
  best_run = FALSE,
  metrics_df = envSDM::sdm_metrics,
  use_metrics = c("auc_po", "CBI_rescale", "IMAE"),
  do_gc = TRUE,
  force_new = FALSE,
  save_to = out_dir,
  ...
)
}
\arguments{
\item{this_taxa}{Character. Name of taxa. Used to name outputs. If `NULL`,
this will be `basename(dirname(out_dir))`.}

\item{out_dir}{Character. Name of directory into which results will be saved.}

\item{algo}{Character. Name of algorithm to use.}

\item{fc}{Character. Used to generate levels of `classes` argument to
`maxnet::maxnet()` that are tuned.}

\item{limit_p}{`TRUE`, `FALSE` or number of predictor variables above which
to limit the use of `p` in the classes argument used in `maxnet::maxnet()`.
Useful with many predictor variables when it becomes unwieldy to generate
interactions for all predictors.}

\item{rm}{Numeric. Used to generate levels of `regmult` argument to
`maxnet::maxnet()` that are tuned.}

\item{trees}{Used to generate the levels of `ntree` argument to
`randomForest::randomForest()` that are tuned. `TRUE` (tune with default
`trees`), `FALSE` (don't tune `trees`) or numeric (the `trees` values to tune
 with).}

\item{mtry}{Used to generate the levels of `mtry` argument to
`randomForest::randomForest()` that are tuned. `TRUE` (tune with sensible guesses for
`mtry`), `FALSE` (only use default `randomForest::randomForest()` `mtry`) or
numeric (the `mtry` values to tune with).}

\item{nodesize}{Used to generate the levels of `nodesize` argument to
`randomForest::randomForest()` that are tuned. `TRUE` (tune with default
`nodesize`), `FALSE` (only use default `randomForest::randomForest()`
`nodesize`) or numeric (the `nodesize` values to tune with).}

\item{keep_model}{Logical. If `TRUE` the model results will be appended as a
list column in the returned tibble (as column `m`)}

\item{best_run}{Logical. If `TRUE` this alters the behaviour of the
`tune_sdm()` by, well, not tuning. :). Sets all blocks to the same value so
no cross-validation.}

\item{metrics_df}{Dataframe. Defines which metrics to use when deciding on
'good' SDMs.}

\item{use_metrics}{Character. Vector of values in metrics_df$metric to use
when finding the 'best' model.}

\item{do_gc}{Logical. Run `base::rm(list = ls)` and `base::gc()` at end of
function? Useful when running SDMs for many, many taxa, especially if done in
parallel.}

\item{force_new}{Logical. If outputs already exist, should they be remade?}

\item{save_to}{Character. Name of path to save results. Defaults to out_dir
which works if not `best_run`. For a best run from `run_full_sdm()`, this
will default to `fs::path(out_dir, "best")`. Otherwise set as anything.}

\item{...}{Passed to `evaluate_sdm()`. e.g. thresholds for use in
`predicts::pa_evaluate()` (as `tr` argument, although if used, the values of
the `thresholds` element of the `pa_ModelEvaluation` object returned by
`predicts::pa_evaluate()` will be limited to the values in `tr`).}
}
\value{
`invisible(NULL)`. `tune.rds` and log written in `save_to`
}
\description{
Tune, and evaluate, species distribution models
}
\examples{

  out_dir <- file.path(system.file(package = "envSDM"), "examples")

  data <- file.path(system.file(package = "predicts"), "ex") |>
    fs::dir_ls(regexp = "\\\\.csv$") |>
    tibble::enframe(name = NULL, value = "path") |>
    dplyr::mutate(taxa = gsub("\\\\.csv", "", basename(path))
                  , presence = purrr::map(path, rio::import, setclass = "tibble")
                  , presence = purrr::map(presence
                                          , \(x) x |>
                                            dplyr::filter(!is.na(lat)
                                                          , !is.na(lon)
                                                          )
                                          )
                  , out_dir = fs::path(out_dir, taxa)
                  )

  purrr::walk(data$out_dir
              , \(x) tune_sdm(out_dir = x)
              )
}
